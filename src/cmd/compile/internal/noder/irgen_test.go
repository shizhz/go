package noder

import (
	"bufio"
	"cmd/compile/internal/amd64"
	"cmd/compile/internal/base"
	"cmd/compile/internal/escape"
	"cmd/compile/internal/inline"
	"cmd/compile/internal/ir"
	"cmd/compile/internal/reflectdata"
	"cmd/compile/internal/ssa"
	"cmd/compile/internal/ssagen"
	"cmd/compile/internal/syntax"
	"cmd/compile/internal/typecheck"
	"cmd/compile/internal/types"
	"cmd/compile/internal/types2"
	"cmd/internal/obj"
	"cmd/internal/objabi"
	"cmd/internal/src"
	"fmt"
	"os"
	"strings"
	"testing"
)

func parseSrc(path, src string) (*syntax.File, error) {
	var mode syntax.Mode
	mode = syntax.AllowGenerics | syntax.CheckBranches
	errh := func(error) {} // dummy error handler so that parsing continues in presence of errors
	return syntax.Parse(syntax.NewFileBase(path), strings.NewReader(src), errh, nil, mode)
}

func defaultImporter() *gcimports {
	return &gcimports{
		packages: map[string]*types2.Package{},
	}
}

func init() {
	amd64.Init(&ssagen.Arch)

	base.Ctxt = obj.Linknew(ssagen.Arch.LinkArch)
	base.Ctxt.DiagFunc = base.Errorf
	base.Ctxt.DiagFlush = base.FlushErrors
	base.Ctxt.Bso = bufio.NewWriter(os.Stdout)

	base.Ctxt.UseBASEntries = base.Ctxt.Headtype != objabi.Hdarwin

	types.LocalPkg = types.NewPkg("", "")
	types.LocalPkg.Prefix = "\"\""

	types.LocalPkg.Height = types.MaxPkgHeight

	types.BuiltinPkg = types.NewPkg("go.builtin", "") // TODO(gri) name this package go.builtin?
	types.BuiltinPkg.Prefix = "go.builtin"            // not go%2ebuiltin

	// pseudo-package, accessed by import "unsafe"
	ir.Pkgs.Unsafe = types.NewPkg("unsafe", "unsafe")

	// Pseudo-package that contains the compiler's builtin
	// declarations for package runtime. These are declared in a
	// separate package to avoid conflicts with package runtime's
	// actual declarations, which may differ intentionally but
	// insignificantly.
	ir.Pkgs.Runtime = types.NewPkg("go.runtime", "runtime")
	ir.Pkgs.Runtime.Prefix = "runtime"

	// pseudo-packages used in symbol tables
	ir.Pkgs.Itab = types.NewPkg("go.itab", "go.itab")
	ir.Pkgs.Itab.Prefix = "go.itab" // not go%2eitab

	// pseudo-package used for methods with anonymous receivers
	ir.Pkgs.Go = types.NewPkg("go", "")

	base.DebugSSA = ssa.PhaseOption

	ssagen.Arch.LinkArch.Init(base.Ctxt)
	ir.EscFmt = escape.Fmt
	ir.IsIntrinsicCall = ssagen.IsIntrinsicCall
	inline.SSADumpInline = ssagen.DumpInline
	ssagen.InitEnv()
	ssagen.InitTables()

	types.PtrSize = ssagen.Arch.LinkArch.PtrSize
	types.RegSize = ssagen.Arch.LinkArch.RegSize
	types.MaxWidth = ssagen.Arch.MAXWIDTH

	typecheck.Target = new(ir.Package)

	typecheck.NeedITab = func(t, iface *types.Type) { reflectdata.ITabAddr(t, iface) }
	typecheck.NeedRuntimeType = reflectdata.NeedRuntimeType // TODO(rsc): TypeSym for lock?

	base.AutogeneratedPos = base.Ctxt.PosTable.XPos(src.MakePos(src.NewFileBase("<autogenerated>", "<autogenerated>"), 1, 0))

	typecheck.InitUniverse()
}

func dumpIrTree(nodes []ir.Node) {
	for _, n := range nodes {
		s := fmt.Sprintf("\nafter noder2 %v", n)
		ir.Dump(s, n)
	}
}

func TestIrTree(t *testing.T) {
	code := `
package p

import "fmt"

// func less[T comparable](i, j T)  {
//     fmt.Printf("i: %v, j: %v\n",i, j)
// }

// func lessint(i, j int)  {
// 	fmt.Printf("i: %v, j: %v\n",i, j)
// }

// func main() {
//    less[int](5,6)
//    less[float32](10, 11)
//    lessint(5,6)
// }

// func init() {
// 	age = 20
// }

var initless bool = less(5,6) || age > 10
var age int = 5

func sum(i, j int)int {
    return i + j
}
func less(i, j int) bool {
	return i < j
}

func init() {
	fmt.Println("Inside init function")
}

func main() {
   s :=  sum(1,2)

   fmt.Printf("Sum: %d\n", s)
}
`

	f, err := parseSrc("generic_testTypecheckConst", code)

	if err != nil {
		panic(err)
	}

	var conf types2.Config
	conf.Trace = false
	conf.Importer = defaultImporter()
	conf.Error = func(err error) {
		fmt.Printf("Typecheck Error: %v\n", err)
	}

	info := types2.Info{
		Types:      make(map[syntax.Expr]types2.TypeAndValue),
		Defs:       make(map[*syntax.Name]types2.Object),
		Uses:       make(map[*syntax.Name]types2.Object),
		Selections: make(map[*syntax.SelectorExpr]*types2.Selection),
		Implicits:  make(map[syntax.Node]types2.Object),
		Scopes:     make(map[syntax.Node]*types2.Scope),
		Inferred:   make(map[syntax.Expr]types2.Inferred),
		// expand as needed
	}

	pkg, err := conf.Check("<no package>", []*syntax.File{f}, &info)
	if err != nil {
		panic(err)
	}

	var m posMap
	g := irgen{
		target: typecheck.Target,
		self:   pkg,
		info:   &info,
		posMap: m,
		objs:   make(map[types2.Object]*ir.Name),
		typs:   make(map[types2.Type]*types.Type),
	}

	p := &noder{
		err:         make(chan syntax.Error),
		trackScopes: base.Flag.Dwarf,
		file:        f,
	}
	g.generate([]*noder{p})

	// dumpIrTree(typecheck.Target.Decls)

	// if initTask := pkginit.Task(); initTask != nil {
	// 	dumpIrTree([]ir.Node{initTask})
	// }
	inline.InlinePackage()

	dumpIrTree(typecheck.Target.Decls)
}
